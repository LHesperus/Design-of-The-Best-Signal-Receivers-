//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? 5? 24 2018 14:49:52
//
//      Input file      : 
//      Component name  : pc
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module pc(Clk_40, Rst, Prf_in, Data_I_in, Data_Q_in, Data_I_out, Data_Q_out, Prf_out,Test_out);
   input         Clk_40;
   input         Rst;
   input         Prf_in;
   input [19:0]  Data_I_in;
   input [19:0]  Data_Q_in;
   output [32:0] Data_I_out;
   output [32:0] Data_Q_out;
   output        Prf_out;
   output reg [33:0] Test_out;
   reg           Prf_out;
   wire          ast_sink_ready[3:0];
   wire          ast_sink_valid;
   wire [33:0]   ast_source_data[3:0];
   wire          ast_source_valid[3:0];
   wire [1:0]    ast_source_error[3:0];
   reg           Prf_in_flag;
   reg [3:0]     Cont;
   wire [33:0]   Data_I_out_temp;
   wire [33:0]   Data_Q_out_temp;
   reg [4:0]     Prf_cont;
   assign ast_sink_valid = 1'b1;
   
   /*
     Fir_I_0 Fir_I_0_u(.clk(Clk_40), 
   .reset_n((~Rst)), .coeff_in_clk(Clk_40), 
   .coeff_in_areset(1'b0), 
   .ast_sink_data(Data_I_in), 
   .ast_sink_ready(ast_sink_ready[0]), 
   .ast_sink_valid(ast_sink_valid), 
   .ast_sink_error(2'b00), 
   .ast_source_data(ast_source_data[0]), 
   .ast_source_ready(1'b1), 
   .ast_source_valid(ast_source_valid[0]), 
   .ast_source_error(ast_source_error[0]));
   */
   
   Fir_64_Q_1 Fir_I_0_u(.clk(Clk_40),
	.reset_n((~Rst)),
	.ast_sink_data(Data_I_in),
	.ast_sink_valid(ast_sink_valid),
	.ast_source_ready(1'b1),
	.ast_sink_error(2'b00),
	.ast_source_data(ast_source_data[0]),
	.ast_sink_ready(ast_sink_ready[0]),
	.ast_source_valid(ast_source_valid[0]),
	.ast_source_error(ast_source_error[0]));
   

   
      Fir_64_I_1 Fir_I_1_u(.clk(Clk_40),
	.reset_n((~Rst)),
	.ast_sink_data(Data_I_in),
	.ast_sink_valid(ast_sink_valid),
	.ast_source_ready(1'b1),
	.ast_sink_error(2'b00),
	.ast_source_data(ast_source_data[1]),
	.ast_sink_ready(ast_sink_ready[1]),
	.ast_source_valid(ast_source_valid[1]),
	.ast_source_error(ast_source_error[1]));
  
   
      Fir_64_Q_1 Fir_Q_0_u(.clk(Clk_40),
	.reset_n((~Rst)),
	.ast_sink_data(Data_Q_in),
	.ast_sink_valid(ast_sink_valid),
	.ast_source_ready(1'b1),
	.ast_sink_error(2'b00),
	.ast_source_data(ast_source_data[2]),
	.ast_sink_ready(ast_sink_ready[2]),
	.ast_source_valid(ast_source_valid[2]),
	.ast_source_error(ast_source_error[2]));
   
   
      Fir_64_I_1 Fir_Q_1_u(.clk(Clk_40),
	.reset_n((~Rst)),
	.ast_sink_data(Data_Q_in),
	.ast_sink_valid(ast_sink_valid),
	.ast_source_ready(1'b1),
	.ast_sink_error(2'b00),
	.ast_source_data(ast_source_data[3]),
	.ast_sink_ready(ast_sink_ready[3]),
	.ast_source_valid(ast_source_valid[3]),
	.ast_source_error(ast_source_error[3]));
   
   /*assign Data_I_out_temp = ast_source_data[0] - ast_source_data[3];
   assign Data_I_out[32] = Data_I_out_temp[33];
   assign Data_I_out[31:0] = Data_I_out_temp[31:0];
   assign Data_Q_out_temp = ast_source_data[1] + ast_source_data[2];
   assign Data_Q_out[32] = Data_Q_out_temp[33];
   assign Data_Q_out[31:0] = Data_Q_out_temp[31:0];
   */
	add_34 Add_I(
	.aclr(Rst),
	.clock(Clk_40),
	.dataa(((~ast_source_data[3]) + 1)),
	.datab(ast_source_data[0]),
	.result(Data_I_out_temp));
	
	add_34 Add_Q(
	.aclr(Rst),
	.clock(Clk_40),
	.dataa(ast_source_data[1]),
	.datab(ast_source_data[2]),
	.result(Data_Q_out_temp));
   assign Data_I_out[32] = Data_I_out_temp[33];
   assign Data_I_out[31:0] = Data_I_out_temp[31:0];
   assign Data_Q_out[32] = Data_Q_out_temp[33];
   assign Data_Q_out[31:0] = Data_Q_out_temp[31:0];
   
   always @(posedge Clk_40)
   begin
	Test_out <= ast_source_data[0];
   end
   
   always @(posedge Clk_40)
      
      begin
         if (Rst == 1'b1)
         begin
            Prf_in_flag <= 1'b0;
            Cont <= 4'b0000;
            Prf_out <= 1'b0;
            Prf_cont <= 5'b11110;
         end
         else
            if (Prf_in == 1'b1 & Prf_cont == 5'b11110)
            begin
               Prf_cont <= 5'b11111;
               Prf_in_flag <= 1'b1;
            end
            else if (Prf_in == 1'b1)
               Prf_cont <= Prf_cont + 1;
            else if (Prf_cont == 5'b01111)
            begin
               Prf_in_flag <= 1'b1;
               Prf_cont <= 5'b11111;
               Cont <= Cont + 1;
            end
            else if (Prf_in_flag == 1'b1)
            begin
               if (Cont == 4'b1000)
               begin
                  Cont <= 4'b0000;
                  Prf_out <= 1'b1;
                  Prf_in_flag <= 1'b0;
               end
               else
                  Cont <= Cont + 1;
            end
            else
               Prf_out <= 1'b0;
      end
   
endmodule
