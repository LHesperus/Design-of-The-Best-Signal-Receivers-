//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? 6? 10 2018 19:11:34
//
//      Input file      : 
//      Component name  : ca_cfar
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module CA_CFAR(CLk_40, Rst, Prf_in, T, Data_I_in, Data_Q_in, Target_flag, Taraget_gate, Prf_out);
   input        CLk_40;
   input        Rst;
   input        Prf_in;
   input [15:0] T;
   input [39:0] Data_I_in;
   input [39:0] Data_Q_in;
   output       Target_flag;
   reg          Target_flag;
   output [9:0] Taraget_gate;
   reg [9:0]    Taraget_gate;
   output       Prf_out;
   reg          Prf_out;
   wire [63:0]  Conv_integer_I_result;
   wire [63:0]  Conv_integer_Q_result;
   wire [63:0]  Mult_f_I_result;
   wire [63:0]  Mult_f_Q_result;
   wire [63:0]  Float_add_result;
   wire [63:0]  Conv_float_result;
   reg [63:0]   Amplitude_shift_in[22:0];
   reg [63:0]   D_delay[2:0];
   wire [63:0]  Par_add_result_temp;
   reg [63:0]   Par_add_result;
   wire [79:0]  Mult_i_result;
   reg [9:0]    Cont;
   wire         Agb;
   
   
   $1 Conv_integer_I_U(.clock(CLk_40), .dataa(Data_I_in), .result(Conv_integer_I_result));
   
   
   $1 Conv_integer_Q_U(.clock(CLk_40), .dataa(Data_Q_in), .result(Conv_integer_Q_result));
   
   Mult_f Mult_f_I_U(.clock(CLk_40), .dataa(Conv_integer_I_result), .datab(Conv_integer_I_result), .result(Mult_f_I_result));
   
   Mult_f Mult_f_Q_U(.clock(CLk_40), .dataa(Conv_integer_Q_result), .datab(Conv_integer_Q_result), .result(Mult_f_Q_result));
   
   Float_add Float_add_U(.clock(CLk_40), .dataa(Mult_f_I_result), .datab(Mult_f_Q_result), .result(Float_add_result));
   
   Conv_float Conv_float_U(.clock(CLk_40), .dataa(Float_add_result), .result(Conv_float_result));
   
   always @(posedge CLk_40)
   begin: xhdl0
      integer      i;
      
      begin
         if (Rst == 1'b1)
            for (i = 22; i >= 0; i = i - 1)
               Amplitude_shift_in[i] <= {(63:0][22-0)+1{1'b0}};
         else
         begin
            Amplitude_shift_in[0] <= Conv_float_result;
            for (i = 22; i >= 1; i = i - 1)
               Amplitude_shift_in[i] <= Amplitude_shift_in[i - 1];
         end
      end
   end
   
   always @(posedge CLk_40)
   begin: xhdl1
      integer      i;
      
      begin
         if (Rst == 1'b1)
            for (i = 2; i >= 0; i = i - 1)
               D_delay[i] <= {(63:0][2-0)+1{1'b0}};
         else
         begin
            D_delay[0] <= Amplitude_shift_in[11];
            for (i = 2; i >= 1; i = i - 1)
               D_delay[i] <= D_delay[i - 1];
         end
      end
   end
   
   Par_add Par_add_U(.clock(CLk_40), .data0x(Amplitude_shift_in[0]), .data10x(Amplitude_shift_in[1]), .data11x(Amplitude_shift_in[2]), .data12x(Amplitude_shift_in[3]), .data13x(Amplitude_shift_in[4]), .data14x(Amplitude_shift_in[5]), .data15x(Amplitude_shift_in[6]), .data1x(Amplitude_shift_in[7]), .data2x(Amplitude_shift_in[15]), .data3x(Amplitude_shift_in[16]), .data4x(Amplitude_shift_in[17]), .data5x(Amplitude_shift_in[18]), .data6x(Amplitude_shift_in[19]), .data7x(Amplitude_shift_in[20]), .data8x(Amplitude_shift_in[21]), .data9x(Amplitude_shift_in[22]), .result(Par_add_result_temp));
   
   always @(posedge CLk_40)
      
      begin
         Par_add_result[63:59] <= {64{Par_add_result_temp[63]}};
         Par_add_result[59:0] <= Par_add_result_temp[63:4];
      end
   
   Mult_i Mult_i_U(.clock(CLk_40), .dataa(Par_add_result), .datab(T), .result(Mult_i_result));
   
   always @(posedge CLk_40)
      
      begin
         if (Rst == 1'b1)
         begin
            Cont <= {10{1'b1}};
            Prf_out <= 1'b0;
         end
         else
            if (Prf_in == 1'b1)
            begin
               Prf_out <= 1'b1;
               Cont <= {10{1'b0}};
            end
            else if (Cont == 10'b1000101001)
            begin
               Prf_out <= 1'b0;
               Cont <= 10'b1000101001;
            end
            else
            begin
               Prf_out <= 1'b0;
               Cont <= Cont + 1;
            end
      end
   
   Compare Compare_U(.clock(CLk_40), .dataa(D_delay[2]), .datab(Mult_i_result[63:0]), .agb(Agb));
   
   always @(posedge CLk_40)
      
      begin
         if (Rst == 1'b1)
         begin
            Target_flag <= 1'b0;
            Taraget_gate <= {10{1'b0}};
         end
         else
            if (Cont > 10'b0001010100 & Cont < 10'b1000101001)
            begin
               if (Agb == 1'b1)
               begin
                  Target_flag <= 1'b1;
                  Taraget_gate <= Cont - 10'b0000111110;
               end
               else
               begin
                  Target_flag <= 1'b0;
                  Taraget_gate <= {10{1'b0}};
               end
            end
            else
            begin
               Target_flag <= 1'b0;
               Taraget_gate <= {10{1'b0}};
            end
      end
   
endmodule
